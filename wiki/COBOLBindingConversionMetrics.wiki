#summary Basic CPU metrics for LegStar COBOL binding.

= Introduction =

There are several performance aspects of interest in LegStar. Here we examine the behavior of the COBOL binding conversions at the data type (or individual field) level.

At the finest level, COBOL binding performs elemental conversions from COBOL data types to Java types. So we first focus on these data types conversions as they will affect all higher level features.

The metrics are focused on CPU as this is likely to be the most important resource from a performance perspective. 

= Measurement procedure =

We used LegStar release 1.2.3 and 1.2.4.

We bundled JUnit test cases for each of the functions we wanted to measure:

|| *Test name*          || * Description* ||
|| AlphanumericToString || PIC X(43) to Java String using IBM01147 EBCDIC character set ||
|| PackedDecimalToBigDecimal || PIC S9(15)V99 COMP-3 to Java BigDecimal ||
|| ZonedDecimalToBigDecimal || PIC S9(15)V99 to Java BigDecimal || 
|| BinaryToBigDecimal || PIC S9(8) COMP to Java BigDecimal ||
|| StringToAlphanumeric || Java String to PIC X(43) using IBM01147 EBCDIC character set ||
|| BigDecimalToPackedDecimal || Java BigDecimal to PIC S9(15)V99 COMP-3 ||
|| BigDecimalToZonedDecimal || Java BigDecimal to PIC S9(15)V99 || 
|| BigDecimalToBinary || Java BigDecimal to PIC S9(8) COMP ||

You can find the JUnit source code [http://code.google.com/p/legstar/source/browse/trunk/legstar-coxbrt/src/test/java/com/legstar/coxb/convert/simple/MeteringTest.java here].

We used [http://jakarta.apache.org/jmeter/ Apache JMeter] to load test each one of these JUnit methods. Each test was run 100000 times with 1000 warmup iterations.

The JMeter configuration files can be found [http://code.google.com/p/legstar/source/browse/#svn/trunk/legstar-coxbrt/src/test/resources/jmeter/convert/simple here].

The target machine is an Intel centrino dual core 2.00 Ghz running JRE 1.6.0_10.

We measured the throughput which is the number of elementary conversions we could perform in a second.

The results should not be interpreted as absolute values. Typically we were running JMeter in GUI mode and performing JUnit assertion on each execution which tends to use CPU cycles and reduce throughput. The results are valid when you compare individual tests to each other though.

= Results =

|| *Test name*          || * Conversions per second (release 1.2.3)* || * Conversions per second (release 1.2.4)* || * variation * ||
|| AlphanumericToString	|| 25490  || 26014  || +2% ||
|| BinaryToBigDecimal	|| 27593  || 27352  || -1% ||
|| ZonedDecimalToBigDecimal	|| 16268  || 24925  || +53% ||
|| PackedDecimalToBigDecimal	|| 24342  || 24166  || -1% ||
|| StringToAlphanumeric	|| 23501  || 22202  || -6% ||
|| BigDecimalToBinary	|| 27754  || 26490  || -5% ||
|| BigDecimalToZonedDecimal	|| 18011  || 21030  || 17% ||
|| BigDecimalToPackedDecimal	|| 26539  || 26021  || -2% ||

= Conclusion =

Release 1.2.4 has considerably improved handling of zoned decimals over release 1.2.3.

It would be useful to complement this with a memory type of analysis (as objects are being created and destroyed as part of the conversion/transformation process).