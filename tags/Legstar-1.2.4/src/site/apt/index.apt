                                             -----
                                            Overview
                                             -----
                                         Fady Moussallam
                                             -----
                                          24 March 2009

Overview

  LegStar is the first {{{http://www.opensource.org/docs/definition.php}open-source}} initiative in the domain of
  legacy application integration.
  
  This page will give you a general idea of LegStar, if you need further details you can read the
   {{{./pdf/legstar-presentation.pdf}presentation document}}.
    
  The latest version is described {{{./latest-release-overview.html}here}}.
  
  We are proud to announce the first official release of {{{http://code.google.com/p/legstar-jbossesb/}LegStar for JBoss ESB}},
  a new deployment option for LegStar. JBoss ESB is a leading open source ESB. LegStar for JBoss ESB provides a deployment
  alternative to J2EE servers, such as Tomcat or Jetty. With JBoss ESB, mainframe integration services can interact with a
  wealth of other services and benefit from more connectivity options.

  Check out the new article {{{http://www.infoq.com/articles/legacy-integration}Mainframe integration with JBoss ESB and LegStar on InfoQ}}.
  
  Check out the new {{{http://www.mulesource.org/display/LEGSTAR/Home}LegStar for MuleSource beta support}}.

{Mapping} COBOL data structures to Complex Types

  Because COBOL is very often the legacy applications development language, LegStar focuses primarily on this
  language.
  
  Since most open-world languages, such as Java, have already been mapped to XML Schema, the approach we have
  taken in LegStar is to map COBOL to XML Schema and then let existing tools, such as,
  {{{http://www.jcp.org/en/jsr/detail?id=222}JAXB}} do the final mapping to the target language.
  
  LegStar has introduced a {{{xml/cobol-binding-1.0.1.xsd}COBOL binding language}}
  to describe how COBOL data items should map to XML Schema elements. That binding language is itself an
  extension to XML Schema (Annotations).
  
  LegStar provides design time tools to help with data structure mapping. Tools are available as ant tasks
  or Eclipse plugins. The following diagram shows the ant file names and Eclipse plugin name as well as
  the LegStar projects where you can find the corresponding code:
  
[images/architecture-schemagen.png] Schema generation
  
  The mapping process can start from COBOL code fragments, XML Schema, Web Service WSDL or Java classes.
  For more details see {{{legstar-schemagen/index.html}COBOL Structures Mapping Generator}},
  and {{{legstar-xsdcgen/index.html}Complex Types Mapping Generator}}.
  
{Converting} mainframe data streams to Java objects or XML

  To support conversion from mainframe data to Java and vice-versa, a design time tool called the
  {{{legstar-coxbgen/}COBOL Binding Generator}} produces marshaling/unmarshaling Java classes. The
  tool starts from a COBOL-annotated XML Schema such as the one produced by the {{{Mapping}Structure Mapping}} tools.
  
  This feature is built on top of the standard {{{http://www.jcp.org/en/jsr/detail?id=222}JAXB framework}}
  which provides Java to XML binding. As a result of this combination, LegStar can convert mainframe data
  streams to/from Java objects and XML.
  
  Using the generated marshaling/unmarshaling Java classes, the {{{legstar-coxbgen/}COBOL Binding Runtime}}
  handles:

  * The various COBOL numeric data types (Zoned decimals, packed decimals, binary, float, double)

  * Code page conversions for character strings

  * Fixed and variable size arrays

  * It also offers unique capabilities to deal with the COBOL REDEFINE clause

[]
  
  Note that conversions do not run on the mainframe itself therefore reducing the mainframe footprint
  of the solution.
  
  The following diagram shows the ant file name, Eclipse plugin and projects for the COBOL Binding
  Generator and the Runtime:

[images/architecture-binding.png] Binding generation and runtime
  
  2 sets of Java classes are produced by the COBOL Binding Generator. The first is actually a set
  of JAXB classes with additional COBOL annotations and the second is used to improve runtime
  conversion performances.
  
  As the diagram shows, the COBOL Binding Runtime can use either the JAXB classes via reflection or the
  Binding classes. The second option is faster since it avoids the expensive reflection process.
  
  The Binding classes have either a reference to the JAXB classes or to the source Java classes.
  In the case where Java classes were used for {{{Mapping}Structure Mapping}}, the Binding classes
  directly marshal/unmarshal to and from these classes. Otherwise, when mapping used COBOL fragments
  or XSD/WSDL, the JAXB classes are used as value objects by the COBOL Binding classes.
  
  The marshaling/unmarshaling capabilities can be used independently from the service-enablement capabilities
  described next.
  
Generating Mainframe Adapter and Proxy Services

  LegStar provides a {{{legstar-cixsgen/index.html}Mainframe Service Generator}} which allows you to map
  mainframe programs to service operations in a bi-directional fashion. An operation is either a
  Web Service operation or a pure java object (POJO) method.
  
  For LegStar a Mainframe Adapter Service is a {{{http://jcp.org/en/jsr/detail?id=224}JAX-WS}} endpoint
  that remotely executes a mainframe program. Mainframe programs are thus exposed as Web Services.

  A LegStar Mainframe Proxy Service acts on behalf of mainframe programs to invoke
  remote Web Services or POJOs. Mainframe programs thus gain access to Web Services and POJOs.
  
  More precisely, for a Mainframe Adapter Service, invoking the operation executes the mainframe program.
  For a Mainframe Proxy Service, the Mainframe program calls the proxy to invoke a target Web Service
  operation or POJO method. Operations are expected to receive a complex type as input and produce a 
  complex type as output.

  The activities involved in generating Mainframe Adapter and Proxy Services are symmetrical and they
  both start from Binding classes for input and output such as the one produced by the
  {{{Converting}COBOL Binding Generator}} tool.
  
  The following diagram shows the ant file names, Eclipse plugins and projects for the Mainframe Service
  Generator and the various runtime modules:

[images/architecture-jaxwsgen.png] Mainframe Adapters and Proxies generation
  
  The Operation Mapping Eclipse plugin helps with tying operations, mainframe programs and their
  corresponding input and outputs. The same data can be passed as parameters to the ant scripts.
  
  Once operations are mapped, the generation of a Mainframe Adapter or Proxy can take place. LegStar
  generates all the artifacts that are needed to create and deploy Mainframe Adapters and Proxies in
  a J2EE container such as Tomcat or Jetty.
  
  Mainframe Adapters are JAX-WS endpoints while Mainframe Proxies are JAX-WS clients when they need to
  invoke a Web Service. Both use the {{{legstar-coxbrt/}COBOL Binding Runtime}} to marshal/unmarshal
  the mainframe data payloads.
  
* Mainframe Adapter Runtime 
  
  The {{{legstar-invoker/index.html}Mainframe Adapter Runtime}} provides the runtime
  invoke mechanism to call a mainframe program. The Adapter Runtime uses a binary protocol
  that optimizes the payload size. This significantly reduces resource consumption on the mainframe.
  
  The Adapter Runtime legacy environment target is primarily IBM CICS. Nothing prevents the
  architecture from being extended to other legacy environments in the future.
  
  LegStar fully supports the CICS channel/container mechanism in addition to the standard commarea.
  LegStar supports multiple input containers and multiple output containers.
  
  In term of transport protocols to CICS, LegStar offers:
  
  * {{{legstar-csokrt/index.html}Socket Transport}}
  
  * {{{legstar-chttprt/index.html}HTTP Transport}}
  
  * {{{legstar-cmqrt/index.html}WebSphere MQ Transport}}
  
[]
  
* Mainframe Proxy Runtime

  Proxies are bundled as Servlets. Once deployed, these Proxy servlets listen for requests from
  the mainframe and access the target Web Service, or POJO, on behalf of the mainframe client program.
  
  Mainframe programs invoke the Proxy over HTTP. The Mainframe Service Generator produces sample
  COBOL code for IBM CICS to show how to perform such a call.

  The {{{legstar-c2wsrt/index.html}Mainframe Proxy Runtime}} provides the servlet-based
  architecture needed to call the target Web Service( using JAX-WS client API) or target POJO.
  
   