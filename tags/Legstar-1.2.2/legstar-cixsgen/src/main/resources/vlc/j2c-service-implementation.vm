##/////////////////////////////////////////////////////////////////////
##Jaxws Component Interface Velocity Template.
##@author Fady
##@version 0.1
##/////////////////////////////////////////////////////////////////////
## ==================================================================
## Create a list of unique import names
##
#macro(addType)
#if (!$importTypes.contains($newType))
#set($ret = $importTypes.add($newType))
#end
#end
## ==================================================================
#parse("vlc/j2c-service-common-package.vm")
#parse("vlc/j2c-service-common-imports.vm")
import javax.jws.WebService;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import com.legstar.host.invoke.HostInvoker;
import com.legstar.host.invoke.HostInvokerException;
import com.legstar.host.invoke.HostInvokerFactory;
import com.legstar.messaging.LegStarAddress;
#if($maps == true)
import java.util.LinkedHashMap;
import java.util.Map;
import com.legstar.coxb.ICobolComplexBinding;
#end
## ==================================================================
## import binding Types
##
#foreach ($cixsOperation in $model.cixsOperations)
#foreach ($cixsStructure in ${cixsOperation.getInput()})
#set($newType = ${helper.getQualClassName(${cixsStructure.coxbPackageName}, ${cixsStructure.coxbType})})
#addType()
#end
#foreach($cixsStructure in ${cixsOperation.getOutput()})
#set($newType = ${helper.getQualClassName(${cixsStructure.coxbPackageName}, ${cixsStructure.coxbType})})
#addType()
#end
#end
## ==================================================================

#foreach($importType in $importTypes)
import ${importType};
#end
## ==================================================================
## Since input and output structures are initialized almost in the
## same way, we use a common macro.
##
#macro(initStruct $cixsStructures $mode $containers)
            /* Prepare the $mode parameter set using static binding */
#if($containers)
            Map <String, ICobolComplexBinding> ${mode}Parts =
              new LinkedHashMap <String, ICobolComplexBinding>(); 
#end
#foreach($cixsStructure in $cixsStructures)
            ${cixsStructure.coxbType} ${mode}${cixsStructure.coxbType} =
                  new ${cixsStructure.coxbType}(#if(${mode} == "input")request#if($containers).get${cixsStructure.jaxbPropertyName}()#end#end);
#if($containers)
            ${mode}Parts.put("${cixsStructure.cicsContainer}", ${mode}${cixsStructure.coxbType});
#end
#end ##foreach            
#end
## ==================================================================
## Setting input or output structure
##
#macro(setStruct $cixsStructures $mode $containers)
#if($containers)${mode}Parts#else#if($cixsStructures.size() > 0)${mode}${cixsStructures.get(0).coxbType}#else null#end#end
#end
## ==================================================================
/**
 * LegStar/Jaxws Component implementation.
 * Each method maps to a CICS program. 
 * 
 * This class was generated by ${generatorName}.
 * Generated on $formattedDate
 */
@WebService(endpointInterface = "${helper.getQualClassName(${model.packageName}, ${model.interfaceClassName})}",
            serviceName = "${model.wsdlServiceName}",
            targetNamespace = "${model.targetNamespace}")
public class ${model.implementationClassName} implements ${model.interfaceClassName} {

    /** The JNDI locator for the configuration file name.*/
    private static final String JNDI_CONFIG_FILE =
        "java:comp/env/legstar/configFileName";
    
    /** The default configuration file name if not recovered from JNDI. */
    private static final String DEFAULT_CONFIG_FILE = "legstar-invoker-config.xml";

    /** The configuration file name. */
    private String mConfigFileName;

    /** Lookup the configuration file name at construction time. */
    public ${model.implementationClassName}() {
        try {
            Context initCtx = new InitialContext();
            mConfigFileName = (String) initCtx.lookup(JNDI_CONFIG_FILE);
        } catch (NamingException e) {
            mConfigFileName = DEFAULT_CONFIG_FILE;
        }
    }
#foreach ($cixsOperation in $model.cixsOperations)
#if(${cixsOperation.cicsChannel})
#set($containers = true)
#else
#set($containers = false)
#end
    /** Properties for operation ${cixsOperation.name}. */
    private static final String  ${cixsOperation.name.toUpperCase()}_PROP_FILE = "${cixsOperation.cicsProgramName.toLowerCase()}.properties";

    /** {@inheritDoc} */
    public final $cixsOperation.responseHolderType ${cixsOperation.name}(
               final $cixsOperation.requestHolderType request,
               final ${model.headerClassName} hostHeader)
               throws ${cixsOperation.faultType} {
    
        $cixsOperation.responseHolderType reply = null;
        try {

            /* Initialize invoker with static data and data from headers */
            HostInvoker mInvoker = HostInvokerFactory.createHostInvoker(
                mConfigFileName, getAddress(hostHeader), ${cixsOperation.name.toUpperCase()}_PROP_FILE);
            String requestID = "${cixsOperation.name}";
            if (hostHeader != null && hostHeader.getHostRequestID() != null) {
            	requestID = hostHeader.getHostRequestID();
            }

#initStruct($cixsOperation.getInput() "input" $containers)

#initStruct($cixsOperation.getOutput() "output" $containers)

            /* Call remote program */
            mInvoker.invoke(requestID,
                    #setStruct($cixsOperation.getInput() "input" $containers),
                    #setStruct($cixsOperation.getOutput() "output" $containers));

#if($containers)
            /* Populate response holder with reply objects */
            reply = new ${cixsOperation.responseHolderType}();
#foreach($cixsStructure in $cixsOperation.getOutput())
            reply.set${cixsStructure.jaxbPropertyName}(output${cixsStructure.coxbType}.get${cixsStructure.jaxbType}());
#end  
#else
#if($cixsOperation.getOutput().size() > 0)
            /* Get reply object */
            reply = output${cixsOperation.getOutput().get(0).coxbType}.get${cixsOperation.getOutput().get(0).jaxbType}();
#end
#end

        } catch (HostInvokerException e) {
            report${cixsOperation.faultType}(e,
              "Failed to invoke host program:");
        }

        return reply;
    }
        
    /**
    * Formats a fault element to notify client of an exception.
    *
    * @param e the exception which occured
    * @param text short message describing the context
    * @throws ${cixsOperation.faultType} the fault exception
    */
    private void report${cixsOperation.faultType}(
        final Exception e,
        final String text) throws ${cixsOperation.faultType} {

        ${cixsOperation.faultInfoType} faultInfo = new ${cixsOperation.faultInfoType}();
        faultInfo.setMessage(e.getMessage());
        faultInfo.setDetail("Operation="
                + "${cixsOperation.name}"
                + " Package="
                + "${cixsOperation.packageName}");
        throw (new ${cixsOperation.faultType}(text + ' ' 
                + faultInfo.getMessage(), faultInfo));

    }

#end
    /**
    * Extracts header data from SOAP header and create an Address.
    * @param hostHeader the JAXB object mapping the SOAP header element
    * @return the new host Address
    */
    private LegStarAddress getAddress(
        final ${model.headerClassName} hostHeader) {
        if (hostHeader == null) {
            return null;
        }
        LegStarAddress address =
            new LegStarAddress(hostHeader.getHostEndPoint());
        address.setHostCharset(hostHeader.getHostCharset());
        address.setHostUserID(hostHeader.getHostUserID());
        address.setHostPassword(hostHeader.getHostPassword());
        address.setHostTraceMode(hostHeader.getHostTraceMode());
        return address;
    }
}
